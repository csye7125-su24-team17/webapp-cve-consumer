package main

import (
	"database/sql"
	"fmt"
	"log"
	"os"

	"github.com/csye7125-su24-team17/webapp/pkg"
	"github.com/IBM/sarama"

	_ "github.com/lib/pq" // Importing the PostgreSQL driver package
)


func main() {
	host := os.Getenv("db_host")
	port := os.Getenv("db_port")
	dbname := os.Getenv("db_name")
	user := os.Getenv("db_user")
	password := os.Getenv("db_password")

	connStr := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=disable", host, port, dbname, user, password)

	// Establish a connection to the PostgreSQL database
	dbConn, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal(err)
	}
	defer dbConn.Close()
	
	kafkaTopic := os.Getenv("kafka_topic")
	kafkaHost := os.Getenv("kafka_host")
	KafkaPort := os.Getenv("kafka_port")
	kafkaUrl := fmt.Sprintf("%s:%s",kafkaHost,KafkaPort)
	worker,err := connectConsumer([]string{kafkaUrl})
	if err!=nil{
		panic(err)
	}
	partitions, err := worker.Partitions(kafkaTopic)
  if err != nil {
      log.Fatalf("Error getting partitions: %v", err)
  }
  for _, partition := range partitions {
    partitionConsumer, err := worker.ConsumePartition(kafkaTopic, partition, sarama.OffsetNewest)
    if err != nil {
      log.Fatalf("Error creating partition consumer: %v", err)
    }
    defer func() {
    	if err := partitionConsumer.Close(); err != nil {
				log.Fatalf("Error closing partition consumer: %v", err)
    	}
    }()
    go func(pc sarama.PartitionConsumer) {
      for message := range pc.Messages() {
				pkg.StoreInDb(dbConn, message.Value)
      }
    }(partitionConsumer)
  }
  select {}
}
func connectConsumer(brokersUrl []string)(sarama.Consumer,error){
	config:= sarama.NewConfig();
	config.Consumer.Return.Errors = true
	conn,err := sarama.NewConsumer(brokersUrl,config)
	if err != nil {
		return nil, err
	}
	return conn,nil
}